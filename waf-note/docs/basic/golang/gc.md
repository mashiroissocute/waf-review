## 内存管理
https://zhuanlan.zhihu.com/p/269621141
## 垃圾回收
https://zhuanlan.zhihu.com/p/297177002
https://developer.aliyun.com/article/775798

### 垃圾回收的意义
长时间允许可能导致内存占满

垃圾回收器主要包括三个目标：

- 无内存泄漏：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾
- 自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾
- 内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率


### 为什么c++无法自动回收内存
指针偏移

### golang垃圾回收
采用三色标级发

利用写屏障，减少STW的时间
在标记的过程中，本来要被回收的内存。goroutine运行中又有对象引用这个内存。就会导致错误的内存回收。所有STW。
但是可以采用写屏障的方式，来阻止这种情景。 goroutine运行中又有对象引用这个内存时，通过写屏障hook，标记该片内存为引用中，这次不回收。下次gc再判断。


## 参考
https://zhuanlan.zhihu.com/p/297177002



## 三色标记清除算法
### 设计
详细的三色标记清楚算法，步骤
### STW问题
需要STW。

（为什么需要STW）
如果不STW，可能导致程序运行期间，垃圾回收器误回收内存，出现悬垂指针。
（详细原因...）

STW对程序的影响。
### 改进思路
让垃圾收集器和程序并发运行。
但是为了保证不出现错误回收内存，遵守以下两个特性之一即可。
#### 强三色不变性
黑色不指向白色。
#### 弱三色不变性
黑色可以指向白色，但是需要存在白色到灰色节点的可达路径。

### 屏障技术
按照最原始三色标记清除算法，强三色和弱三色都是无法保证的。因此还需要有屏障技术的支持。
垃圾回收中的屏障技术：（钩子函数）
在操作内存的时候，利用钩子函数，额外进行一些操作。

（屏障技术的书面解释）
垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。

因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序。

#### 读屏障
大量的读内存操作，会导致读屏障对用户程序性能产生影响。
#### 写屏障
##### 插入写屏障
保证了强三色不变性。 增加引用白色对象时， 将白色对象标记为灰色。（将**有存活可能的对象都标记成灰色**以满足强三色不变性。允许部分内存对象本次不回收，下次GC再回收）

##### 删除写屏障
保证弱三色不变性。 解除引用白色对象时，将白色对象标记为灰色。

## Golang的实现方式
###  v1.7 版本之前 插入写屏障 + STW
运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，**如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描**，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。

（栈对象开启插入写屏障将导致巨大开销）

### v1.8 版本  混合写屏障
组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会**将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色**：

```
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```
为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要**将创建的所有新对象都标记成黑色**，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。