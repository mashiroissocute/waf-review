## 存储层次
![alt text](image-16.png)
越靠近cpu，存储介质价格越高，存储容量越小。

### 存储级别
可执行内存: CPU寄存器 +  主存（CPU高速缓存 + 主内存 + 磁盘缓存）。

辅助存储: 磁盘等。

二者的区别在于OS访问的方式不同，可执行内存通过load、store指令可以直接访问。而辅助存储需要通过I/O设备管理去访问，过程涉及中断、设备驱动程序运行、物理设备启动。通常，可执行内存访问消耗时间远小于辅助存储访问。



### 存储类型

- 寄存器: 访问速度与cpu执行速度一致，通常只有两位数的寄存器存储。
- 高速缓存: 位于寄存器和内存之间的物理高速缓存，真实存在，大小一般在几MB左右。
- 磁盘缓存: 在内存上暂时存储经常访问的磁盘数据，避免磁盘访问，实际上在内存上，并非单独的一块存储。


## 程序与内存

程序想要执行，必须经历编译、链接、装入的流程。
![alt text](image-17.png)



### 装入
将程序将入内存中执行的过程。

程序的每个模块的逻辑起始地址都是从0开始的。如何装入内存分为两种方式：


- 绝对装入 ： 适用于单进程场景，程序内存和实际内存保持一致。
- 可重定位装入: 在并发场景下，我们无法预知进程要使用的内存位置。因此在装入的时候，需要动态转换地址。例如，一个模块的指令为load 2500，但是被装入到了10000起始地址的内存上时，需要动态转换2500地址到12500:
![alt text](image-18.png)

### 链接
将程序各个模块和库函数链接未来一个可执行目标的过程。

链接各个模块分为两种方式：

- 静态链接： 装入内存之前，将模块和库链接为一个整体。需要修改模块之间的逻辑地址。
![alt text](image-19.png)

- 动态链接： 将模块的链接推迟到程序执行时。首先将程序开始模块装入内存，当执行到需要用到另外的模块时，如果该模块没有在内存中，此时os再去寻找该模块，并装入内存，然后链接到调用者模块上。

```
好处一：不需要用到的模块，不会被装入内存。加快程序装入和减少内存使用。
好处二：可以实现将一个模块连接到几个应用上，实现模块共享。
好处三：可以按照模块进行修改程序，不需要整体修改。 
```



## 分页存储

分页存储是内存管理的方式。

在分页存储之前，将模块装入内存都是采用的连续内存分配的方法。连续内存分配容易导致内存碎片。
分页存储的思想是将进程直接分散的装入到不相邻的内存分区中。

进程的逻辑内存和实际的物理内存都被按照固定的页面大小进行划分，在为进程分配内存时，以页为单位，将进程的若干页装入到内存的不相邻的页面中。



常规分页存储，地址变化方式如下：
![alt text](image-20.png)
页表寄存器： 页表放在内存中，页表寄存器保存了页表在内存中起始位置和页表长度。

具有快表的分页存储，地址变化方式如下：
![alt text](image-21.png)
由于页表是放在内存中的，所以cpu执行程序指令时，访问一次内存数据，实际上需要访问两次内存。
第一次访问页表，拿到逻辑地址对应的内存页号。第二次访问内存地址。为了提高地址变换速度，新增了一个输入寄存器，用于缓存一部分页表数据。命中缓存时，可以将访问内存次数缩减到一次。


> 内存分配和回收

内存分配是在程序需要执行时，将程序一次性分散的加载到内存页中。

内存回收是在程序执行完毕时，将程序涉及的内存页一次性回收。

即使过程中，程序因为I/O等操作阻塞，也不会回收内存资源。这将带来一些问题：

- 一次性：大型作业所需超出内存大小时，无法一次性装载。
- 驻留性：存在大量作业需要运行时，由于内存只在程序执行完之后回收，OS只能一批执行完之后换下一批执行。


## 虚拟内存

虚拟内存的提出时为了解决 一次性 和 驻留性 这两个问题。


虚拟内存是一种时间换空间的概念。不需要一次性装载程序到内存中，而是基于分页存储，按需一页一页的加载程序。当内存满时，还涉及将内存页回收的机制。

因此使用虚拟内存，可以解决一次性问题和驻留性问题


### 局部性原理

> 为什么即使不一次性装载所有程序到内存中，程序仍然可以运行呢？

因为程序在执行的过程中存在局部性原理。

局部性原理是指，程序的执行局限一个部分，访问的空间也局限于一个区域。

![alt text](image-22.png)



### 虚拟存储器
![alt text](image-23.png)

虚拟存储器需要在分页内存管理的基础上，支持内存的请求和回收。因此，至少需要支持如下：
![alt text](image-24.png)
#### 页表
新增了状态位等
![alt text](image-25.png)

#### 缺页中断

cpu现场保存 -> 分析中断原因 -> 转入缺页中断处理程序

#### 地址转换
![alt text](image-26.png)

### 页面置换算法

- FIFO
- LRU


## linux程序内存布局
![alt text](image-28.png)

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；

注意，如上内存布局是指进程的虚拟内存，而非实际的物理内存（进程在物理内存上是，分页分散装入的）。

### 进程申请内存和操作系统管理内存的关系
如上图所示，linux的进程内存组织方式是一致的。

进程的内存地址空间是从0开始的，并且是连续的空间。
实际上，进程的内存管理都是面向的虚拟内存。进程申请内存，释放内存都是在进程的虚拟内存空间上。

> 例如，进程申请了一个1GB的堆内存，此时进程的虚拟内存空间确实是被占用了1GB的内存。
但是计算机的物理内存实际上还没有被占用。只有后续进程真正使用该1GB内存时，OS发起缺页中断从进程虚拟内存读取内存页到物理内存时，才会体现到物理内存的占用上。



#### 栈内存
进程的局部变量和函数调用上下文都是在栈空间中的，栈空间是一种线性空间。
只需要SP、BP等寄存器就可以管理栈空间。
当新建局部变量需要空间时，只需要SP向低地址移动即可。
当函数退出时，只需要回退SP和BP指针即可。

栈内存的一切回收和分配都是由操作系统自动实现的。

#### 堆内存
操作系统无法帮助进程的管理虚拟内存的堆内存。因为操作系统不知道当前这片内存空间是处于有效还是无效的状态。
只有堆内存使用者才知道什么时候应该申请内存和回收内存。
所有的编程语言都是虚拟内存堆内存的使用者。有些编程语言支持自动回收堆内存，有些编程语言需要手动回收堆内存。

> 那么虚拟内存的堆内存是如何申请和管理的呢？

这涉及到虚拟内存申请和管理库。比如 [tcmalloc](../lib/tcmalloc.md)

