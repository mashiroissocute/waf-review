### tcp 在调用connect失败后要不要重新socket？
connect（套接字默认阻塞）出错返回的情况：

调用connect时内核发送一个SYN分节，若无响应则等待6s后再次发送一个，仍无响应则等待24s再发送一个，若总共等了75s后仍未收到响应则返回ETIMEDOUT错误；

若对客户的SYN的响应是RST，则表示该服务器主机在我们指定的端口上面没有进程在等待与之连接，例如服务器进程没运行，客户收到RST就马上返回ECONNREFUSED错误；

若客户发出的SYN在中间的某个路由上引发了一个“destination unreachable”（目的不可达）ICMP错误，客户主机内核保存该消息，并按1中所述的时间间隔发送SYN，在某个规定的时间（4.4BSD规定75s）仍未收到响应，则把保存的ICMP错误作为EHOSTUNREACH或ENETUNREACH错误返回给进程。

若connect失败则该套接字不再可用，必须关闭，我们不能对这样的套接字再次调用connect函数。在每次connect失败后，都必须close当前套接字描述符并重新调用socket。


### 进程间通信方式
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，内核是可以共享的。在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）

- 管道

管道允许进程以先进先出的方式传送数据，是半双工的，意味着数据只能往一个方向流动。因此当双方通信时，必须建立两个管道。

管道的实质就是在内核中创建一个缓冲区，管道一端的进程进入管道写数据，另一端的进程进入管道读取数据。

管道分为pipe和FIFO两种

pipe：用于相关联的进程，比如父进程和子进程之间的通信。
FIFO：命名管道，即任何进程可以根据管道的文件名将其打开和读写。
缺点：管道本质上是通过内核交换数据的，因此通信效率很低，不适合频繁交换数据的情况。

匿名管道的周期随着进程的创建而创建，销毁而销毁。

- 消息队列

消息队列是保存在内核中的链表，由一个个独立的数据块组成，消息的接收方和发送方要约定具体的消息类型。当进程从消息队列中读取了相关数据块，则内核会将该数据块删除。跟管道相比，消息队列不一定按照先进先出的方式读取，也可以按照消息类型进行兑取。

消息队列的生命周期与内核相关，如果不显示的删除消息队列，则消息队列会一直存在

消息队列这种通信方式，跟收发邮件类似。两个进程你来我往的进行沟通

缺点：不能实现实时通信。数据块是有大小限制的。消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

- 共享内存 + 信号量

共享内存技术就是要解决用户态和内核态之间频繁发生拷贝过程的。现代操作系统对于内存管理普遍采用的是虚拟内存技术，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中。

数据不需要在不同进程之间进行复制，这是最快的一种IPC

共享内存技术的实质就是拿出一块虚拟地址空间，映射到相同的物理内存中。这样的好处是一个进程写入数据后另一个进程可以立刻看到，不用进行拷贝。效率很高。


- 信号量（同步原语，并不叫IPC）

本质是一个计数器，用于为多个进程提供对共享对象的访问

共享内存在效率高的同时也带来了新的问题，即如果多个进程同时对一个共享内存进行操作，会产生冲突造成不可预计的后果。

为了不冲突，共享内存在一个时间段只能有一个进程访问，就出现了信号量。

信号量其实是一个计数器，用于实现进程间的互斥和同步。

信号量表示资源的数量。 P操作 会把信号量-1，-1之后如果信号量的值<0，则表示资源已经被占用，进程需要阻塞等待。如果信号量-1后>= 0，表明进程可以正常执行。V操作跟P操作正好相反。


进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。

若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。

直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。


- 信号

上面那几种进程间通信，都是常规状态下的。异常状态下的需要用信号来通知进程。

信号和信号量就像雷锋和雷峰塔的区别。

可以在任何时刻给进程发送信号，信号是进程间通信或操作的一种异步通信机制。

收到信号后进程对信号的处理有三种方式

如果是系统定义的信号函数，执行默认操作。

**SIGINT：**程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。

**SIGQUIT：**程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。

**SIGALRM：**定时器信号。

**SIGTERM：**结束进程信号。shell下执行kill 进程pid发送该信号。

捕捉信号。用户可以给信号定义信号处理函数，表示收到信号后该进程该怎么做。

忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。

- unix域套接字

具体指unix域间套接字。socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。**UNIX域套接字与TCP套接字相比较，在同一台主机的传输速度前者是后者的两倍。**这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。




### 进程/线程被阻塞发生什么


- 1. 系统调用时，被阻塞则加入到对象的等待队列中，例如p操作，socket操作。都会挂到对象的等待队列。

- 2. 当收到v操作时，或者socket事件就绪时，会取出等待队列上的进程，加入到cpu的就绪队列中，等待执行。

- 3. 当cpu时间片用完之后，将进程重新加入就绪队列。




### 什么是mmap？
mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。


### mmap和常规文件操作的区别
常规文件的操作如下：

进程发起读文件请求。
内核查找文件描述符，定位到内核已打开的文件信息，找到文件的inode。
查看文件页是否在缓存中，如果存在则直接返回这片页面
如果不存在，缺页中断，需要定位到该文件的磁盘地址处，将数据从磁盘复制到页缓存中，然后发起页面读写过程，将页缓存中的数据发送给用户
常规文件需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。

而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。


#### mmap函数
mmap函数第一种用法是映射磁盘文件到内存中。（共享内存）

而malloc使用的mmap函数的第二种用法，即匿名映射，匿名映射不映射磁盘文件，而是向映射区申请一块内存。当申请小内存的时，malloc使用sbrk分配内存；当申请大内存时，使用mmap函数申请内存；但是这只是分配了虚拟内存，还没有映射到物理内存，当访问申请的内存时，才会因为缺页异常，内核分配物理内存。


### 深入理解alloc函数

- 内存碎片处理
- 内存池问题

