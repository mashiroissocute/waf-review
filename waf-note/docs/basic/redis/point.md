## redis



### redis缓存相比本地缓存的优劣

- 本地缓存没有网络开销，速度更快。
- 本地缓存受单机内存大小影响，无法存储大量数据，redis分布式缓存集群可以。
- 本地缓存在多个节点之间容易出现不一致性，redis缓存是中心化缓存，可以保持一致。例如缓存session。

### 性能

4c8g redis可以抗10w qps
4c8g mysql可以抗5000 qps

- I/O：redis使用内存存储数据，内存读写比mysql的磁盘读写快很多
- 数据结构：mysql使用B+树做索引访问数据，O(logn)时间复杂度。redis使用hash作为索引，O(1)时间复杂度。
- 线程模型：redis使用多路复用+单线程模式减少线程切换


### 大key问题

redis是单线程模型，如果某个请求访问的key对应的内容很大，会导致处理较慢，阻塞其他请求。

针对大key文件，采用延迟操作或者拆分大key的操作。

例如 del 大key，替换为异步删除


### 热key文件

在分布式redis缓存中，如果某一个节点的key是热点访问的key，会导致节点之间负载不均。

做法是把热key在节点之间进行复制，让部分请求落到其他节点上，保证负载相对平衡。

或者使用读写分离架构，所有节点的数据都是一致的，使用轮训的方式保证负载均衡。



### 如何保证缓存和实际存储的一致性

CAP理论的三个属性
一致性（Consistency）：所有节点在同一时刻看到的数据是一样的。强一致性要求一旦数据更新，所有节点的数据立即同步更新。
可用性（Availability）：系统能够及时响应客户端的请求，即使部分节点或网络出现故障。
分区容错性（Partition Tolerance）：当系统内部出现网络分区时，系统仍然能够继续提供服务。例如部分节点故障。

CAP存在不可能三角。

使用缓存的场景主要是要保证系统的可用性。分区容错性不受人物控制，因此只能牺牲一致性。满足AP。

在使用缓存时，最好使缓存和实际存储保持最终一定性即可：

访问时，先访问缓存，不存在则访问下一级存储，并缓存结果。

修改时，删除缓存，并修改下一级存储。

### 缓存雪崩

大量不同key缓存同一时间失效。

为key设置不同的缓存时间解决。



### 缓存击穿

高并发同key请求没有命中缓存，同时请求数据库，造成数据库压力。

使用singleflight解决。



### 缓存穿透

故意访问缓存不存在的key，直连数据库，造成数据库压力。

使用布隆过滤器解决


#### 布隆过滤器

使用多个hash函数同时计算key并取模存储在bitmap中。

检查key是否存在是基于hash后位置是否全为1。

可能会存在hash冲突。所以在key经过检查后在过滤器中不一定真的存在，但是不在就一定不在。



