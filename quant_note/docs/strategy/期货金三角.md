# 期货金三角
与现货金三角策略一直，添加了做空的策略。
2023.10.08

## todo
由于exit trade了之后，会有一段lock trade时间。
因此，exit_long和entry_short的信号必须不能重合。
否组无法在多单之后开启空单
需要探索新的exit信号


## 期货
### 代码
- can_short标识
```python
# --- Do not remove these libs ---
from functools import reduce
from freqtrade.strategy import IStrategy
from freqtrade.strategy import CategoricalParameter, DecimalParameter, IntParameter
from pandas import DataFrame
# --------------------------------

import talib.abstract as ta
import freqtrade.vendor.qtpylib.indicators as qtpylib


class ThreeMAStrategyfuture(IStrategy):
    """

    author@: Gert Wohlgemuth

    idea:
        buys and sells on crossovers - doesn't really perfom that well and its just a proof of concept
    """
    
    INTERFACE_VERSION: int = 3
    can_short = True
    
    
    # Minimal ROI designed for the strategy.
    # This attribute will be overridden if the config file contains "minimal_roi"
    minimal_roi = {
        "0": 0.3
    }

    # Optimal stoploss designed for the strategy
    # This attribute will be overridden if the config file contains "stoploss"
    stoploss = -0.05

    # Optimal timeframe for the strategy
    timeframe = '4h'
    
    startup_candle_count: int = 55

    buy_range_short = IntParameter(5, 10, default=5)
    buy_range_mid = IntParameter(10, 20, default=10)
    buy_range_exit = IntParameter(20, 30, default=20)
    buy_range_long = IntParameter(30, 60, default=55)
    
    # Optional order type mapping.
    order_types = {
        'entry': 'market',
        'exit': 'market',
        'stoploss': 'market',
        'stoploss_on_exchange': False
    }

    # Optional order time in force.
    order_time_in_force = {
        'entry': 'GTC',
        'exit': 'GTC'
    }
    
    
    plot_config = {
        'main_plot': {
            'ema1': {},
            'ema2': {},
            'ema3': {}, 
        },
     
    }

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

       
        dataframe['ema1'] = ta.EMA(dataframe, timeperiod=self.buy_range_short.value)
        dataframe['ema2'] = ta.EMA(dataframe, timeperiod=self.buy_range_mid.value)
        dataframe['ema3'] = ta.EMA(dataframe, timeperiod=self.buy_range_long.value)

        dataframe['ema4'] = ta.EMA(dataframe, timeperiod=self.buy_range_exit.value)
        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the buy signal for the given dataframe
        :param dataframe: DataFrame
        :return: DataFrame with buy column
        """
        dataframe.loc[
            (
                qtpylib.crossed_above(
                    dataframe['ema2'],
                    dataframe['ema3']
                ) &
                (dataframe['ema1'] > dataframe['ema2'])
            ),
            'enter_long'] = 1
        
        
        dataframe.loc[
            (
                qtpylib.crossed_below(
                    dataframe['ema2'],
                    dataframe['ema3']
                ) &
                (dataframe['ema1'] < dataframe['ema2'])
            ),
            'enter_short'] = 1

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the sell signal for the given dataframe
        :param dataframe: DataFrame
        :return: DataFrame with buy column
        """
        dataframe.loc[
            (
                qtpylib.crossed_below(
                    dataframe['ema1'],
                    dataframe['ema4']
                )
            ),
            'exit_long'] = 1
        
        
        dataframe.loc[
            (
               qtpylib.crossed_above(
                    dataframe['ema1'],
                    dataframe['ema4']
                )
            ),
            'exit_short'] = 1
        return dataframe

```

### 配置
- trading_mode为futures，即期货合约。暂时不支持margin现货杠杆。
- 控仓为isolated为逐仓，暂不支持cross全仓。
```json
{
    "max_open_trades": -1,
    "stake_currency": "USDT",
    "stake_amount": 20,
    "tradable_balance_ratio": 0.99,
    "fiat_display_currency": "USD",
    "dry_run": false,
    "db_url": "sqlite:///tradesv3.production.sqlite",
    "cancel_open_orders_on_exit": false,
    "trading_mode": "futures",
    "margin_mode": "isolated",
    "unfilledtimeout": {
        "entry": 10,
        "exit": 10,
        "exit_timeout_count": 0,
        "unit": "minutes"
    },
    "entry_pricing": {
        "price_side": "other",
        "use_order_book": true,
        "order_book_top": 1,
        "price_last_balance": 0.0,
        "check_depth_of_market": {
            "enabled": false,
            "bids_to_ask_delta": 1
        }
    },
    "exit_pricing":{
        "price_side": "other",
        "use_order_book": true,
        "order_book_top": 1
    },
    "exchange": {
        "name": "binance",
        "key": "",
        "secret": "",
        "ccxt_config": {},
        "ccxt_async_config": {},
        "pair_whitelist": [
            "BTC/USDT:USDT",
            "ETH/USDT:USDT",
            "SOL/USDT:USDT",
            "MAGIC/USDT:USDT",
            "MATIC/USDT:USDT"
        ],
        "pair_blacklist": [
            "BNB/.*"
        ]
    },
    "pairlists": [
        {
            "method": "StaticPairList"
        }
    ],
    "telegram": {
        "enabled": true,
        "token": "6655605797:AAGSLJRxfA9cXcXhRvyBlztYL8yv4ASkChE",
        "chat_id": "6554307219"
    },
    "api_server": {
        "enabled": true,
        "listen_ip_address": "0.0.0.0",
        "listen_port": 8080,
        "verbosity": "error",
        "enable_openapi": false,
        "jwt_secret_key": "c2f52a7654042c4a18116e0b36f6f71a4c065bb3d2f741cbc165d78b45b48779",
        "ws_token": "lFqsGnoneowgkSCmUx0kJadxLNXeTnqQFw",
        "CORS_origins": [],
        "username": "",
        "password": ""
    },
    "bot_name": "freqtrade",
    "initial_state": "running",
    "force_entry_enable": false,
    "internals": {
        "process_throttle_secs": 5
    }
}



```
