# 期货均线粘合发散
均线粘合一段时间后，发散开
（分久必合，合久必分）
2023.10.12

## 代码
```python
# --- Do not remove these libs ---
from functools import reduce
from freqtrade.strategy import IStrategy
from freqtrade.strategy import CategoricalParameter, DecimalParameter, IntParameter
from pandas import DataFrame
# --------------------------------

import talib.abstract as ta
import freqtrade.vendor.qtpylib.indicators as qtpylib

# 均线横盘粘合后发散
class DevStrategyfuture(IStrategy):
    """

    author@: lucasssli

    idea: 均线横盘粘合后发散
        
    """
    
    INTERFACE_VERSION: int = 3
    can_short = True
    
    
    # Minimal ROI designed for the strategy.
    # This attribute will be overridden if the config file contains "minimal_roi"
    minimal_roi = {
        "0": 0.3
    }

    # Optimal stoploss designed for the strategy
    # This attribute will be overridden if the config file contains "stoploss"
    stoploss = -0.05
    # trailing_stop = True

    # Optimal timeframe for the strategy
    timeframe = '4h'
    
    startup_candle_count: int = 65

    buy_range_short = IntParameter(5, 10, default=5)
    buy_range_mid = IntParameter(10, 20, default=10)
    buy_range_long = IntParameter(20, 30, default=55)
    

    
    
    # 设置判断均线粘合的阈值
    distance_threshold = 0.005  # 均线之间的距离阈值 0.5%  代表粘合
    slope_threshold = 0.005  # 均线的斜率阈值 0.5%  代表横盘
    
    period_convergence = 8 # convergence回看天数 
    satisfy_convergence = 6 # convergence满足天数
    
    period_divergence = 2 # divergence回看天数
    satisfy_divergence = 2 # divergence满足天数
    


    # Optional order type mapping.
    order_types = {
        'entry': 'market',
        'exit': 'market',
        'stoploss': 'market',
        'stoploss_on_exchange': False
    }

    # Optional order time in force.
    order_time_in_force = {
        'entry': 'GTC',
        'exit': 'GTC'
    }
    
    
    plot_config = {
        'main_plot': {
            'EMA5': {},
            'EMA10': {},
            'EMA20': {}, 
        }, 
        'subplots': {
            "convergence": {
                "convergence": {},    
            },
            "divergence_up": {
                "divergence_up": {},    
            },
            "divergence_down": {
                "divergence_down": {},
            },
        },
    }

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

       
        dataframe['EMA5'] = ta.EMA(dataframe, timeperiod=self.buy_range_short.value)
        dataframe['EMA10'] = ta.EMA(dataframe, timeperiod=self.buy_range_mid.value)
        dataframe['EMA20'] = ta.EMA(dataframe, timeperiod=self.buy_range_long.value)
        
        # 计算均线之间的距离
        dataframe['EMA5_10_distance'] = (dataframe['EMA5'] - dataframe['EMA10']) 
        dataframe['EMA5_20_distance'] = (dataframe['EMA5'] - dataframe['EMA20']) 
        dataframe['EMA10_20_distance'] = (dataframe['EMA10'] - dataframe['EMA20']) 
        
        # 计算均线之间的距离rate
        dataframe['EMA5_10_distance_rate'] = (dataframe['EMA5'] - dataframe['EMA10']) / dataframe['EMA10']
        dataframe['EMA5_20_distance_rate'] = (dataframe['EMA5'] - dataframe['EMA20']) / dataframe['EMA20']
        dataframe['EMA10_20_distance_rate'] = (dataframe['EMA10'] - dataframe['EMA20']) / dataframe['EMA20']
        
        # 计算均线的变化rate
        dataframe['EMA5_slope'] = (dataframe['EMA5'].pct_change(-1))
        dataframe['EMA10_slope'] = (dataframe['EMA10'].pct_change(-1))
        dataframe['EMA20_slope'] = (dataframe['EMA20'].pct_change(-1))
        

        # 判断均线是否粘合
        dataframe['convergence'] = ((abs(dataframe['EMA5_10_distance_rate']) < self.distance_threshold) & 
                                (abs(dataframe['EMA5_20_distance_rate']) < self.distance_threshold) & 
                                (abs(dataframe['EMA10_20_distance_rate']) < self.distance_threshold))
        
        # 判断均线是否向上发散
        dataframe['divergence_up'] = ((dataframe['convergence']==False) & (dataframe['EMA5']>dataframe['EMA10']) & (dataframe['EMA10']>dataframe['EMA20']))
        
        # 判断均线是否向下发散
        dataframe['divergence_down'] = ((dataframe['convergence']==False) & (dataframe['EMA5']<dataframe['EMA10']) & (dataframe['EMA10']<dataframe['EMA20']))

        print(dataframe[['EMA5_10_distance_rate','EMA5_20_distance_rate','EMA10_20_distance_rate','convergence','divergence_up','divergence_down']])
        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the buy signal for the given dataframe
        :param dataframe: DataFrame
        :return: DataFrame with buy column
        """
        dataframe.loc[
            (   
                ((dataframe['divergence_up'].rolling(self.period_divergence).sum() >= self.satisfy_divergence) &
                (dataframe['convergence'].shift(self.period_divergence).rolling(self.period_convergence).sum() >= self.satisfy_convergence))
            ),
            'enter_long'] = 1
        
        dataframe.loc[
            (   
               ((dataframe['divergence_down'].rolling(self.period_divergence).sum() >= self.satisfy_divergence) &
                (dataframe['convergence'].shift(self.period_divergence).rolling(self.period_convergence).sum() >= self.satisfy_convergence))
            ),
            'enter_short'] = 1

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Based on TA indicators, populates the sell signal for the given dataframe
        :param dataframe: DataFrame
        :return: DataFrame with buy column
        """
        dataframe.loc[
            (
                qtpylib.crossed_below(
                    dataframe['EMA5'],
                    dataframe['EMA20']
                )
            ),
            'exit_long'] = 1
        
        
        dataframe.loc[
            (
               qtpylib.crossed_above(
                    dataframe['EMA5'],
                    dataframe['EMA20']
                )
            ),
            'exit_short'] = 1
        return dataframe


#  (dataframe['divergence_down'].rolling(self.period_divergence).sum() >= self.satisfy_convergence)
```


## Dryrun配置
```python
{
    "max_open_trades": -1,
    "stake_currency": "USDT",
    "stake_amount": 100,
    "tradable_balance_ratio": 0.99,
    "fiat_display_currency": "USD",
    "dry_run": true,
    "dry_run_wallet": 20000,
    "db_url": "sqlite:///decon.dryrun.sqlite",
    "cancel_open_orders_on_exit": false,
    "trading_mode": "futures",
    "margin_mode": "isolated",
    "unfilledtimeout": {
        "entry": 10,
        "exit": 10,
        "exit_timeout_count": 0,
        "unit": "minutes"
    },
    "entry_pricing": {
        "price_side": "other",
        "use_order_book": true,
        "order_book_top": 1,
        "price_last_balance": 0.0,
        "check_depth_of_market": {
            "enabled": false,
            "bids_to_ask_delta": 1
        }
    },
    "exit_pricing":{
        "price_side": "other",
        "use_order_book": true,
        "order_book_top": 1
    },
    "exchange": {
        "name": "binance",
        "key": "",
        "secret": "",
        "ccxt_config": {},
        "ccxt_async_config": {},
        "pair_whitelist": [
            "BTC/USDT:USDT"
        ],
        "pair_blacklist": [
            "BNB/.*"
        ]
    },
    "pairlists": [
        {
            "method": "RemotePairList",
            "number_assets": 300,
            "pairlist_url" : "https://remotepairlist.com?q=d6dab7e6c832b6b7"
        }
    ],
    "telegram": {
        "enabled": true,
        "token": "6424666625:AAEuezGvdIgfJBhBtvUzRjsSTmBegNIin5s",
        "chat_id": "6554307219"
    },
    "api_server": {
        "enabled": true,
        "listen_ip_address": "0.0.0.0",
        "listen_port": 8081,
        "verbosity": "error",
        "enable_openapi": false,
        "jwt_secret_key": "deb1cd340cd8b8244ec9df7b361c0e078f134ed9881eb6f598b83ae651c708be",
        "ws_token": "7SUlvTqmPXXBwGIBHIastfhRTdW-Vmsg8A",
        "CORS_origins": [],
        "username": "",
        "password": ""
    },
    "bot_name": "freqtrade",
    "initial_state": "running",
    "force_entry_enable": false,
    "internals": {
        "process_throttle_secs": 5
    }
}
```

