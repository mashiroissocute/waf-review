## 值的做
- https://leetcode.cn/problems/merge-k-sorted-lists/description/
- https://leetcode.cn/problems/middle-of-the-linked-list/
- https://leetcode.cn/problems/linked-list-cycle-ii/description/
- https://leetcode.cn/problems/intersection-of-two-linked-lists/description/



## two list合并

```golang

head0 := &list{
    -1,
    nil
}

h0 = head0
h1 = head1
h2 = head2

for h1 != nil && h1 != nil {
    // 比较大小
    h0.next = littelOne(h1,h2)
    h1 = h1.next or h2 = h2.next
    h0 = h0.next
}

if h1 != nil {
    h0.next = h1
}

if h2 != nil {
    h0.next = h2
}

return head0.next

```


## K list合并

```golang

import container/heap



type PriorityQueue []*list 


func (pq *PriotityQueue) Len() int {
    return len(pq)
}

func (pq *PriotityQueue) Swap(i,j int){
    temp = pq[i]
    pq[i] = pq[j]
    pq[j] = temp
}

func (pq *PriotityQueue) Less(i,j int){
    return pq[i].val < pq[j].val
}


func (pq *PriotityQueue) push(x interface{}) {
    node := x.(*list)
    *pq = apppend(*pq,x)
}

func (pq *PriotityQueue) pop() interface{} {
    old := *PriotityQueue
    n := len(old)
    node = old[n-1]
    *pq = old[0:n-1]
    return node
}



pq := heap.New(PriorityQueue)

head := *list{
    -1,
    nil
}
h0 = head


//初始化heap
for _,node := range lists{
    pq.Push(node)
}

//构造mergelist
for pq.Len() != 0 {
    curNode := pq.Pop().(*listNode)


    head.next = curNode
    
    nextNode := curNode.next
    curNode.next = nil
    
    pq.Push(curNode)
    
}

return h0.next




```




## list分割

```golang

head1 := &list{
    -1,
    nil
}
h1 = head1

head2 := &list{
    -1,
    nil
}
h2 = head2


h0 = head0
for h0 != nil {
    if h0.val < x {
        head1.next = h0
        head1 = head1.next

    }else{
        head2.next = h0
        head2 = head2.next
    }
    hn = h0.next
    h0.next = nil
    h0 = hn
}

head1.next = head2.next

return h1.next
```



## 链表环

```golang
func ... {
    slow, fast := head, head
    for fast != nil && fast.next != nil {
        slow = slow.next
        fast = fast.next.next

        if  slow == fast {
            // 寻找环入口

            // h0 = head
            // for h0 != slow {
            //     h0 = h0.next
            //     slow = slow.next
            // }
            // return h0


            return true
        }
    }

    return false
}
```


## 相交链

```golang

func ... {
    
    h0,h1:= headA,headB

    for {
        if h0 == nil && h1 == nil {
            return false
        }

        if h0 == h1 && h0 != nil{
            return true
        }


        if h0 == nil {
            h0 = headB
        }else{
            h0 = h0.next
        }

        if h1 == nil {
            h1 = headA
        }else{
            h1 = h1.next
        }
    }
}
```
